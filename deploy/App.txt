<!DOCTYPE html>
<html>
<head>
    <title>Current Data Release Burndown</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Mar 19 2015 15:55:51 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Mar 19 2015 15:55:51 GMT-0600 (MDT)";
        var CHECKSUM = 78880127052;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
 Ext.define("Rally.apps.charts.settings.RadioGroupSetting", {
        extend: "Ext.form.FieldContainer",

        config: {
            settingName: undefined
        },

        constructor: function(config) {
            this.mergeConfig(config);
            this.callParent(arguments);
        },

        getSetting: function() {
            return this.settingsParent.app.getSetting(this.settingName);
        },

        setRadioValue: function (cmp) {
            this.setRadioToCustomValue(cmp, this.getSetting());
        },

        setRadioToCustomValue: function (cmp, customValue) {
            var value = {};
            value[cmp.name] = customValue;
            cmp.setValue(value);
        }
    });
 
 Ext.define("Rally.apps.charts.settings.SettingsChangeMixin", {

     sendSettingsChange: function(artifact) {
         if (this.settingsParent) {
             this.settingsParent.sendSettingsChange(artifact, this);
         }
     },

     receiveSettingsChange: function(artifact) {

     }

 });
 
 Ext.define("Rally.apps.charts.settings.TimeboxPicker", {
     extend: "Rally.apps.charts.settings.RadioGroupSetting",
     alias: "widget.charttimeboxpicker",

     mixins: [
         "Ext.form.field.Field"
     ],

     config: {
         settingName: "chartTimebox"
     },

     settingsParent: undefined,

     initComponent: function () {
         this.callParent(arguments);
         this._addRadioGroup();
     },

     _addRadioGroup: function () {
         this.add({
             xtype: "radiogroup",
             name: this.settingName,
             itemId: this.settingName,
             label: "Level",
             columns: [160, 100, 100],
             vertical: false,
             items: [
                 { boxLabel: "Release", name: this.settingName, inputValue: "release", checked: true },
                 { boxLabel: "Iteration", name: this.settingName, inputValue: "iteration" }
             ],
             listeners: {
                 beforerender: this.setRadioValue,
                 scope: this
             },
             config: {
                 cls: "levelchooser"
             }
         });
     }
 });

Ext.define("Rally.apps.charts.settings.DataTypePicker", {
     extend: "Rally.apps.charts.settings.RadioGroupSetting",
     alias: "widget.chartdatatypepicker",

     mixins: [
         "Ext.form.field.Field",
         "Rally.apps.charts.settings.SettingsChangeMixin"
     ],

     config: {
         settingName: "chartAggregationType"
     },

     settingsParent: undefined,

     initComponent: function () {
         this.callParent(arguments);
         this.add(this._addRadioGroup());
     },

     _addRadioGroup: function () {
         return {
             xtype: "radiogroup",
             name: this.settingName,
             columns: [160, 100],
             vertical: false,
             items: [
                 { boxLabel: "Story Plan Estimate", name: this.settingName, inputValue: "storypoints", checked: true },
                 { boxLabel: "Story Count", name: this.settingName, inputValue: "storycount" }
             ],
             listeners: {
                 beforerender: this.setRadioValue,
                 scope: this
             }
         };
     }
 }); 

Ext.define("Rally.apps.charts.settings.ChartDisplayTypePicker", {
     extend: "Rally.apps.charts.settings.RadioGroupSetting",
     alias: "widget.chartdisplaytypepicker",

     mixins: [
         "Ext.form.field.Field"
     ],

     config: {
         settingName: "chartDisplayType"
     },

     settingsParent: undefined,

     initComponent: function () {
         this.callParent(arguments);
         this.add(this._getPicker());
     },

     _getPicker: function () {
         return {
             xtype: "radiogroup",
             name: this.settingName,
             columns: [160, 100],
             vertical: false,
             items: [
                 { boxLabel: "Line", name: this.settingName, inputValue: "line", checked: true },
                 { boxLabel: "Column", name: this.settingName, inputValue: "column" }
             ],
             listeners: {
                 beforerender: this.setRadioValue,
                 scope: this
             }
         };
     }
 });


 Ext.define("Rally.apps.charts.settings.ChartDisplayTypePicker", {
     extend: "Rally.apps.charts.settings.RadioGroupSetting",
     alias: "widget.chartdisplaytypepicker",

     mixins: [
         "Ext.form.field.Field"
     ],

     config: {
         settingName: "chartDisplayType"
     },

     settingsParent: undefined,

     initComponent: function () {
         this.callParent(arguments);
         this.add(this._getPicker());
     },

     _getPicker: function () {
         return {
             xtype: "radiogroup",
             name: this.settingName,
             columns: [160, 100],
             vertical: false,
             items: [
                 { boxLabel: "Line", name: this.settingName, inputValue: "line", checked: true },
                 { boxLabel: "Column", name: this.settingName, inputValue: "column" }
             ],
             listeners: {
                 beforerender: this.setRadioValue,
                 scope: this
             }
         };
     }
 });

  Ext.define("Rally.apps.charts.DateMixin", {

        dateFormatters: [
            {key: "MMM", value: "%b"},
            {key: "MM", value: "%m"},
            {key: "dd", value: "%d"},
            {key: "yyyy", value: "%Y"}
        ],

        dateToStringDisplay: function (date) {
            return Ext.Date.format(date, 'm/d/Y');
        },

        dateToString: function (date) {
            return Ext.Date.format(date, 'Y-m-d\\TH:i:s.u\\Z');
        },

        dateStringToObject: function (dateStr) {
            var finalIndex = dateStr.indexOf('T'),
                dateObj;

            if (finalIndex > -1) {
                dateStr = dateStr.slice(0, dateStr.indexOf('T'));
            }

            dateObj = this._splitDateParts(dateStr);

            return new Date(dateObj.year, dateObj.month, dateObj.day);
        },

        _splitDateParts: function (dateStr) {
            if (this._shouldSplitOnDash(dateStr)) {
                return this._objectFromYearFirstDate(dateStr.split('-'));
            }
            else {
                return this._objectFromMonthFirstDate(dateStr.split('/'));
            }
        },

        _objectFromYearFirstDate: function (dateArray) {
            if (dateArray.length !== 3) {
                return { year: 0, month: 0, day: 0 };
            }

            dateArray[1] = (parseInt(dateArray[1], 10) - 1).toString();

            return {
                year: dateArray[0],
                month: dateArray[1],
                day: dateArray[2]
            };
        },

        _objectFromMonthFirstDate: function (dateArray) {
            if (dateArray.length !== 3) {
                return { year: 0, month: 0, day: 0 };
            }

            dateArray[0] = (parseInt(dateArray[0], 10) - 1).toString();

            return {
                month: dateArray[0],
                day: dateArray[1],
                year: dateArray[2]
            };
        },

        _shouldSplitOnDash: function (dateStr) {
            return dateStr.split('-').length === 3;
        }

    });

/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

    Ext.define("Rally.apps.charts.burndown.BurnDownCalculator", {
        extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",
        mixins: [
            "Rally.apps.charts.DateMixin"
        ],

        getDerivedFieldsOnInput: function () {
            var completedStates = this.config.completedScheduleStateNames,
                aggregationType = this.config.chartAggregationType;

            return [
                {
                    "as": "RemainingPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if(completedStates.indexOf(ss) < 0) {
                            if(aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                },
                {
                    "as": "AcceptedPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if (completedStates.indexOf(ss) > -1) {
                            if (aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                }
            ];
        },

        getMetrics: function () {
            return [
                {
                    "field": "RemainingPoints",
                    "as": "To Do",
                    "f": "sum"
                },
                {
                    "field": "AcceptedPoints",
                    "as": "Accepted",
                    "f": "sum"
                }
            ];
        },

        getSummaryMetricsConfig: function () {
            return [
                {
                    'as': 'Scope_max',
                    'f': function(seriesData) {
                            var max = 0, i = 0;
                            for (i=0;i<seriesData.length;i++) {
                                if(seriesData[i].Accepted + seriesData[i]['To Do'] > max) {
                                    max = seriesData[i].Accepted + seriesData[i]['To Do'];
                                }
                            }
                            return max;
                         }
                }
            ];
        },

        getDerivedFieldsAfterSummary: function () {
            return  [
                {
                    "as": "Ideal",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        var max = summaryMetrics.Scope_max,
                            increments = seriesData.length - 1,
                            incrementAmount;
                        if(increments === 0) {
                            return max;
                        }
                        incrementAmount = max / increments;
                        return Math.floor(100 * (max - index * incrementAmount)) / 100;
                    },
                    "display": "line"
                },
                {
                    "as": "Prediction",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        return null;
                    },
                    "display": "line",
                    "dashStyle": "Dash"
                }
            ];
        },

        getProjectionsConfig: function () {
            var days = (this.scopeEndDate.getTime() -
                Rally.util.DateTime.fromIsoString(this.startDate).getTime()) / (24*1000*60*60);
            var doubleTimeboxEnd = Ext.Date.add(Rally.util.DateTime.fromIsoString(this.startDate), Ext.Date.DAY, (Math.floor(days) * 2) - 1);
            var timeboxEnd = Ext.Date.add(this.scopeEndDate, Ext.Date.DAY, -1);
            if(this.projectionsConfig === undefined) {
                this.projectionsConfig = {
                    doubleTimeboxEnd: doubleTimeboxEnd,
                    timeboxEnd: timeboxEnd,

                    series: [
                        {
                            "as": "Prediction",
                            "field": "To Do"
                        }
                    ],
                    continueWhile: function (point) {
                        var dt = Rally.util.DateTime.fromIsoString(point.tick);
                        var end = (this.series[0].slope >= 0) ? this.timeboxEnd : this.doubleTimeboxEnd;
                        return point.Prediction > 0 && dt < end;
                    }
                };
            }
            return this.projectionsConfig;
        },

        _firstNonZero: function(data) {
             var i;
             for(i=0;i<data.length;i++) {
                if(data[i] > 0) {
                    return i;
                }
             }
             return 0;
        },

        _leastSquares: function(todoValues, firstIndex, lastIndex) {
            var n = (lastIndex + 1) - firstIndex;
            var i;
            var sumx = 0.0, sumx2 = 0.0, sumy = 0.0, sumy2 = 0.0, sumxy = 0.0;
            var slope, yintercept;

            //Compute sums of x, x^2, y, y^2, and xy
            for (i = firstIndex; i <= lastIndex; i++) {
                sumx  = sumx  + i;
                sumx2 = sumx2 + i * i;
                sumy  = sumy  + todoValues[i];
                sumy2 = sumy2 + todoValues[i] * todoValues[i];
                sumxy = sumxy + i * todoValues[i];
            }
            slope = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
            yintercept = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx);

            return {slope: slope, yintercept: yintercept};
        },
         runCalculation: function (snapshots) {
            console.log('snaps',snapshots);         
            var chartData = this.callParent(arguments);

            if(chartData && chartData.projections && chartData.projections.series[0].slope > 0) {
            // if the slope is positive, try using least squares.  If that's also positive, then use the first result
                var todoData = chartData.series[0].data;
                var firstTodoIndex = this._firstNonZero(todoData),
                    lastTodoIndex = (todoData.length - 1) - chartData.projections.pointsAddedCount;

                var results = this._leastSquares(todoData, firstTodoIndex, lastTodoIndex);

                // override the prediction line only if least squares says the slope isn't positive
                if(results.slope <= 0) {
                    this.projectionsConfig.series[0].slope = results.slope;

                    chartData = this.callParent(arguments);

                    // project the plot back to the first todo value
                    chartData.series[3].data[firstTodoIndex] = ((results.slope * firstTodoIndex) + results.yintercept) + (chartData.series[3].data[lastTodoIndex] - ((results.slope * lastTodoIndex) + results.yintercept));
                    chartData.series[3].connectNulls = true;
                    this.projectionsConfig = undefined;
                } else {
                // DE18732, if the slope is up, truncate it at 1.25 of the max Ideal
                    var predictionCeiling = 1.25 * chartData.series[2].data[0];
                    if (_.max(chartData.series[3].data) > predictionCeiling) {
                        var i;
                        var maxVal = predictionCeiling;
                        for(i=0;i < chartData.series[3].data.length;i++) {
                            if(chartData.series[3].data[i] > predictionCeiling) {
                                chartData.series[3].data[i] = maxVal;
                                maxVal = null;
                            }
                        }
                    }
                }

            }

            if(new Date() < this.scopeEndDate) {
                this._recomputeIdeal(chartData, this.scopeEndDate);
            }

            return chartData;
        },

        _recomputeIdeal: function(chartData, endDate) {
             var index;
             if(chartData.categories.length < 1) {
                return;
             }
             if(this.workDays.length < 1) {
                return;
             }

             var lastDate = Ext.Date.parse(chartData.categories[chartData.categories.length - 1], 'Y-m-d');
             if(endDate > lastDate) {
                // the scopeEndDate date wasn't found in the current categories...we need to extend categories to include it
                // (honoring "workDays").

                index = chartData.categories.length;
                var dt = Ext.Date.add(lastDate, Ext.Date.DAY, 1);
                while (dt < endDate) {
                    while (this.workDays.indexOf(Ext.Date.format(dt, 'l')) === -1) {
                        dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                    }
                    if (dt < endDate) {
                        chartData.categories[index++] = Ext.Date.format(dt, 'Y-m-d');
                    }
                    dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                }
                index = chartData.categories.length - 1;
             } else {
                 // it is in "scope"...set index to the index of the last workday in scope
                 index = this._indexOfDate(chartData, endDate);
                 if(index === -1) {
                    // it's in "scope", but falls on a non-workday...back up to the previous workday
                    while (this.workDays.indexOf(Ext.Date.format(endDate, 'l')) === -1) {
                        endDate = Ext.Date.add(endDate, Ext.Date.DAY, -1);
                        index = this._indexOfDate(chartData, endDate);
                    }
                 }
             }
             if(index < 0) {
                return;
             }
             // set first and last point, and let connectNulls fill in the rest
             var i;
             var seriesData = chartData.series[2].data;
             for (i=1;i<index;i++) {
                seriesData[i] = null;
             }
             seriesData[index] = 0;
        },

        _indexOfDate: function(chartData, date) {
             var dateStr = Ext.Date.format(date, 'Y-m-d');
             return chartData.categories.indexOf(dateStr);
        },

        _removeFutureSeries: function (chartData, seriesIndex, dayIndex) {
            if(chartData.series[seriesIndex].data.length > dayIndex) {
                while(++dayIndex < chartData.series[seriesIndex].data.length) {
                    chartData.series[seriesIndex].data[dayIndex] = null;
                }
            }
        },

        _projectionsSlopePositive: function (chartData) {
            if(chartData.projections && chartData.projections.series) {
                return chartData.projections.series[0].slope >= 0;
            }

            return true;
        }
    });

Ext.define("Rally.apps.charts.burndown.BurnDownChart", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        defaultChartComponentConfig: function() {
            return {
                xtype: "rallychart",
                itemId: "burndownchart",

                aggregationErrorMessage: "No data to display. Check the data type setting for displaying data based on count versus plan estimate.",

                storeType: "Rally.data.lookback.SnapshotStore",
                storeConfig: {
                    find: {
                  //          "_TypeHierarchy": { '$in' : ['Defect','HierarchicalRequirement']}, //[ -51038, -51006 ] },
                  //          "Children": null
                    },
                    fetch: ["ScheduleState", "PlanEstimate", "ObjectId", "_ValidFrom", "_ValidTo"],
                    hydrate: ["ScheduleState"],
                    sort: {
                        "_ValidFrom": 1
                    },
                    compress: true,
                    useHttpPost: true
                },

                calculatorType: "Rally.apps.charts.burndown.BurnDownCalculator",
                calculatorConfig: {
                    timeZone: "GMT",
                    completedScheduleStateNames: ["Accepted", "Released"],
                    enableProjections: true

                    //chartAggregationType: ''
                },

                chartColors: ["#005eb8", "#8dc63f", "#666666", "#c0c0c0"],

                chartConfig: {
                    chart: {
                        zoomType: "xy"
                    },
                    xAxis: {
                        categories: [],
                        tickmarkPlacement: "on",
                        tickInterval: 7,
                        title: {
                            text: "Days",
                            margin: 12
                        },
                        maxPadding: 0.25,
                        labels: {
                            x: 0,
                            y: 20,
                            overflow: "justify"
                        }
                    },
                    yAxis: [],
                    tooltip: {
                        formatter: function () {
                            var floatValue = parseFloat(this.y),
                                value = this.y;

                            if (!isNaN(floatValue)) {
                                value = Math.floor(floatValue * 100) / 100;
                            }

                            return "" + this.x + "<br />" + this.series.name + ": " + value;
                        }
                    },
                    plotOptions: {
                        series: {
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: true
                                    }
                                }
                            },
                            connectNulls: true
                        },
                        column: {
                            pointPadding: 0,
                            borderWidth: 0,
                            stacking: null,
                            shadow: false
                        }
                    }
                }
            };

        }
    });


Ext.define("Rally.apps.charts.burndown.BurnDownSettings", {
        requires: [
            "Rally.apps.charts.settings.ChartDisplayTypePicker",
            "Rally.apps.charts.settings.DataTypePicker",
            "Rally.apps.charts.settings.TimeboxPicker",
            "Rally.ui.CheckboxField"
        ],

        config: {
            app: undefined
        },
        
        constructor: function (config) {
            this.mergeConfig(config);
        },

        _buildSettingsComponent: function (type, label, name) {
            var self = this;

            var componentAdded = function (cmp) {
                this.settingsParent = this.settingsParent || self;
            };

            var settings = {
                xtype: type,
                label: label,
                listeners: {
                    added: componentAdded
                }
            };
            if (name) {
                settings.name = name;
                settings.cls = "settings-" + name;
            }
            return settings;
        },

        _isOnScopedDashboard: function() {
            return this.app.isOnScopedDashboard() && !!this.app.context.getTimeboxScope();
        },

        getFields: function() {
            var dataTypePicker = this._buildSettingsComponent("chartdatatypepicker", "Data Type"),
                displayPicker = this._buildSettingsComponent("chartdisplaytypepicker", "Chart Type"),
                timeboxPicker = this._buildSettingsComponent("charttimeboxpicker", "Level"),
                labelNameVisible = this._buildSettingsComponent("rallycheckboxfield", "Show Iteration Labels", 'showLabels'),
                useCurrentData = this._buildSettingsComponent("rallycheckboxfield", "Use Current Data", 'useCurrentArtifacts');
            
            if(this._isOnScopedDashboard()) {
                return [dataTypePicker, displayPicker, labelNameVisible,useCurrentData];
            } else {
                return [timeboxPicker, dataTypePicker, displayPicker, labelNameVisible,useCurrentData];
            }
        }
        

    });

 Ext.define("Rally.apps.charts.IntegrationHeaders", {

        keyConverters : {
            name : function() { return 'X-RallyIntegrationName'; },
            vendor : function() { return 'X-RallyIntegrationVendor'; },
            platform : function() { return 'X-RallyIntegrationPlatform'; },
            os : function() { return 'X-RallyIntegrationOS'; },
            version : function() { return 'X-RallyIntegrationVersion'; },
            library : function() { return 'X-RallyIntegrationLibrary'; }
        },

        constructor: function(config) {
            this.headers = {
                name : 'A2 Chart',
                vendor : 'Rally Software'
            };

            Ext.merge(this.headers, config.integrationHeaders || {});
            this.callParent(config);
        },
        withName : function(nm) {
            this.headers.name = nm || this.headers.name;
            return this;
        },
        withVendor : function(v) {
            this.headers.vendor = v || this.headers.vendor;
            return this;
        },
        withPlatform : function(newPlatform) {
            this.headers.platform = newPlatform || this.headers.platform;
            return this;
        },
        withVersion : function(newVersion) {
            this.headers.version = newVersion || this.headers.version;
            return this;
        },
        withOS : function(newOS) {
            this.headers.os = newOS || this.headers.os;
            return this;
        },
        withLibrary : function(newLibrary) {
            this.headers.library = newLibrary || this.headers.library;
            return this;
        },
        applyTo : function(config) {
            config.headers = config.headers || {};
            Ext.merge(config.headers, this.build());
            return config;
        },
        build : function() {
            var h = {};
            for (var k in this.headers) {
                if (this.headers.hasOwnProperty(k)) {
                    if (this.headers[k] === null) { continue; }
                    var key = this._keyConverter(k)(k);
                    h[key] = this.headers[k];
                }
            }
            return h;
        },
        _keyConverter: function(key) {
            if (this.keyConverters.hasOwnProperty(key)) {
                return this.keyConverters[key];
            } else {
                return function(x) {return x;};
            }
        }
    });
   Ext.define('Rally.app.TimeboxScopedApp', {
        extend: 'Rally.app.App',
        requires: [
            'Rally.ui.gridboard.TimeboxBlankSlate',
            'Rally.ui.combobox.IterationComboBox',
            'Rally.ui.combobox.ReleaseComboBox',
            'Rally.app.TimeboxScope'
        ],
        items: [
            {
                xtype: 'container',
                cls: 'header'
            }
        ],

        /**
         * @cfg {String}
         * Type of scope. Supported types are 'iteration' or 'release'.
         */
        scopeType: null,

        /**
         * @cfg {String}
         * The message to display when no scope objects are found.
         */
        noScopeMsg: null,

        /**
         * @cfg {String}
         * The message to use for the link to create a new scope object.
         */
        createScopeMsg: null,

        /**
         * @cfg {Object}
         * Additional config to pass to the combobox
         */
        comboboxConfig: null,

        useTimeboxScope: true,

        /**
         * @cfg {Boolean}
         * Whether or not this app is compatible with unscheduled work
         */
        supportsUnscheduled: true,

        /**
         * @override
         * @inheritdoc
         */
        launch: function() {
            var context = this.getContext();
            if (context.getTimeboxScope() && context.getTimeboxScope().getType() === this.scopeType) {
                this.onScopedDashboard = true;
                this.getHeader().hide();
                this.onTimeboxScopeChange(context.getTimeboxScope());
            } else {
                this.onScopedDashboard = false;
                this._addScopeComboBox();
            }
        },

        isOnScopedDashboard: function() {
            return this.onScopedDashboard;
        },

        /**
         * Called when any timebox scope change is received.
         * @protected
         * @param {Rally.app.TimeboxScope} timeboxScope The new scope
         */
        onTimeboxScopeChange: function(timeboxScope) {
            if(timeboxScope && timeboxScope.getType() === this.scopeType) {
                this.callParent(arguments);

                if(this.down('#unscheduledBlankSlate')) {
                    this.remove(this.down('#unscheduledBlankSlate'));
                }
                if(timeboxScope.getRecord() !== null || this.supportsUnscheduled) {
                    this.onScopeChange(timeboxScope);
                } else {
                    this._addUnscheduledBlankSlate();
                }
            }
        },

        /**
         * Called when a timebox scope change of the current scope type is received
         * @template
         * @param {Rally.app.TimeboxScope} scope The new scope
         */
        onScopeChange: function(scope) {},

        /**
         * Called when there are no timebox items to display
         * @template
         */
        onNoAvailableTimeboxes: function() {},

        getHeader: function() {
            return this.down('container[cls=header]');
        },

        isShowingBlankSlate: function() {
            return this.down('#blankSlate') !== null;
        },

        _addScopeComboBox: function() {
            var xtype = 'rally' + this.scopeType + 'combobox';

            var defaultComboBoxConfig = {
                xtype: xtype,
                stateful: true,
                stateId: this.getAppId() + 'scoping',
                storeConfig: {
                    context: {
                        project: Rally.util.Ref.getRelativeUri(this.getContext().getDataContext().project),
                        workspace: Rally.util.Ref.getRelativeUri(this.getContext().getDataContext().workspace)
                    }
                },
                plugins: [
                    {
                        ptype: 'rallycomboboxrealtimeupdate',
                        realtimeContext: this.getContext()
                    }
                ],
                listeners: {
                    ready: this._onScopeComboBoxReady,
                    select: this._onScopeComboBoxChange,
                    scope: this
                },
                allowNoEntry: this.supportsUnscheduled
            };

            this.getHeader().add(Ext.merge(defaultComboBoxConfig, this.comboboxConfig));
        },

        _onScopeComboBoxChange: function(comboBox) {
            this._changeScope(comboBox);
        },

        _onScopeComboBoxReady: function(comboBox) {
            var noTimeboxesCount = comboBox.allowNoEntry ? 1 : 0;
            if (comboBox.getStore().getCount() > noTimeboxesCount) {
                this._changeScope(comboBox);
            } else {
                this._addBlankSlate();
            }
        },

        /**
         * Changes the scope in the context
         * @param comboBox The Scope combo box
         * @private
         */
        _changeScope: function(comboBox) {
            var wasShowingBlankSlate = this.isShowingBlankSlate();
            if (wasShowingBlankSlate) {
                this._removeBlankSlate();
            }
            this.getContext().setTimeboxScope(Ext.create('Rally.app.TimeboxScope', {
                record: comboBox.getRecord(),
                type: this.scopeType
            }));
            this.onTimeboxScopeChange(this.getContext().getTimeboxScope());
        },

        _removeBlankSlate: function() {
            this.remove(this.down('#blankSlate'));
        },

        _addBlankSlate: function() {
            this.add({
                itemId: 'blankSlate',
                xtype: 'rallytimeboxblankslate',
                timeboxType: this.scopeType,
                context: this.getContext()
            });
            this.onNoAvailableTimeboxes();
        },

        _addUnscheduledBlankSlate: function() {
            this.add({
                itemId: 'unscheduledBlankSlate',
                xtype: 'container',
                cls: 'no-data-container',
                items: [
                    {
                        xtype: 'component',
                        cls: 'primary-message',
                        tpl: 'No {scopeType} selected.',
                        data: {scopeType: this.scopeType}
                    },
                    {
                        xtype: 'component',
                        cls: 'secondary-message',
                        tpl: 'Select {timebox} above to view {appName}.',
                        data: {
                            timebox: this.scopeType === 'iteration' ? 'an iteration' : 'a release',
                            appName: this.appName
                        }
                    }
                ]
            });
            this.onNoAvailableTimeboxes();
        }
    });
Ext.define('CustomApp', {
extend: 'Rally.app.TimeboxScopedApp',
 logger: new Rally.technicalservices.Logger(),

    settingsScope: 'workspace',

    requires: [
        'Rally.apps.charts.burndown.BurnDownSettings',
        'Rally.data.wsapi.Store',
        'Rally.util.Help',
        'Rally.ui.combobox.IterationComboBox',
        'Rally.ui.combobox.ReleaseComboBox',
        'Rally.apps.charts.IntegrationHeaders',
        'Rally.apps.charts.burndown.BurnDownChart'
    ],

    mixins: [
        'Rally.apps.charts.DateMixin'
    ],

    cls: 'burndown-app',

    items: [
        {
            xtype: 'container',
            itemId: 'header',
            cls: 'header'
        }
    ],

    help: {
        id: 278
    },

    scopeObject: undefined,

    customScheduleStates: ['Accepted'], // a reasonable default
    config: {
        defaultSettings: {
            showLabels: true,
            chartAggregationType: 'storypoints',
            chartDisplayType: 'line',
            chartTimebox: 'release',
            title: '',
            useCurrentArtifacts: true
        }
    },

    chartComponentConfig: undefined,

    getSettingsFields: function () {
        this.chartSettings = this.chartSettings || Ext.create('Rally.apps.charts.burndown.BurnDownSettings', {
            app: this
        });

        return this.chartSettings.getFields();
    },

    onScopeChange: function (scope) {
        if (!this.ignoreOnScopeChange) {
            this._rebuildChartForScope(scope.getRecord().get('_ref'));
        }
    },

    launch: function () {
        if (this._settingsInvalid()) {
            if (this.owner) {
                this.owner.showSettings();
                return;
            }
        }
        this.customScheduleStates = null;
        this.chartComponentConfig = Ext.create('Rally.apps.charts.burndown.BurnDownChart', this).defaultChartComponentConfig();

        Ext.create('Rally.apps.charts.IntegrationHeaders',this).applyTo(this.chartComponentConfig.storeConfig);

     //   this._addHelpComponent();
        this._loadUserStoryModel();
        this._saveScopeType();
        this.callParent(arguments);

        if (!this.isOnScopedDashboard()) {
            this.ignoreOnScopeChange = true;
            this._getScopePicker().on('ready', this._loadScopePreference, this, {single: true});
        }
  },
    _rebuildChartForScope: function(scopeRef) {
        this._destroyChart();

        this._saveScopePreference(scopeRef);
        this._loadScopeObject(scopeRef);
    },

    _destroyChart: function () {
        this.remove('burndownchart');
    },

    _saveScopePreference: function (scopeRef) {
        if (!this.isOnScopedDashboard()) {
            var settings = {};
            settings[this._getScopeType()] = scopeRef;

            Rally.data.PreferenceManager.update({
                appID: this.getContext().get('appID'),
                settings: settings,
                scope: this
            });
        }
    },

    _loadScopePreference: function (picker) {
        Rally.data.PreferenceManager.load({
            appID: this.getContext().get('appID'),
            success: function (preferences) {
                var scopeRef = preferences[this._getScopeType()];
                if (!scopeRef || scopeRef === 'undefined') {
                    var pickerRecord = picker.getRecord();
                    if (pickerRecord) {
                        scopeRef = pickerRecord.get('_ref');
                        this._saveScopePreference(scopeRef);
                    }
                }
                this.ignoreOnScopeChange = false;

                if (scopeRef && scopeRef !== 'undefined') {
                    this._setScopeValue(scopeRef);
                    scopeRef = this._getScopePicker().getValue();
                    if (scopeRef) {
                        this._rebuildChartForScope(scopeRef);
                    }
                }
            },
            scope: this
        });
    },

    _setScopeValue: function (scopeRef) {
        this._getScopePicker().setValue(scopeRef);
    },

    _loadTimeboxes: function() {
        Ext.create('Rally.data.wsapi.Store', {
            model: this.scopeObject._type,
            filters: [
                {
                    property: 'Name',
                    operator: '=',
                    value: this.scopeObject.Name
                },
                {
                    property: this._getScopeObjectStartDateName(),
                    operator: '=',
                    value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                },
                {
                    property: this._getScopeObjectEndDateName(),
                    operator: '=',
                    value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                }
            ],
            context: this.getContext().getDataContext(),
            fetch: ['ObjectID'],
            limit: Infinity,
            autoLoad: true,
            listeners: {
                load: function (store, records) {
                    this._getTimeboxesInScope(store, records);
                },
                scope: this
            }
        });
    },

    _onScopeObjectLoaded: function (record) {
        this._setScopeFromData(record);

        this._updateStoreConfig();
        
        this._updateChartTitle();
        this._updateYAxis();

        this._addDateBounds();
        this._addAggregationTypeToCalculator();
        this._updateCompletedScheduleStates();
        this._loadTimeboxes();
    },
    _updateStoreConfig: function(){
        
    },
    _fetchScopeObjects: function(){
        var filters = this.getContext().getTimeboxScope().getQueryFilter();
        this.logger.log('_fetchReleaseObjects', filters);
        
        filters = filters.or(Ext.create('Rally.data.wsapi.Filter', {
            property: "DirectChildrenCount",
            value: 0
        }));

        Ext.create('Rally.data.wsapi.Store',{
            model: 'HierarchicalRequirement',
            fetch: 'ObjectID',
            autoLoad: true, 
            filters: [scope.getQueryFilter()],
            limit: 'Infinity',
            listeners: {
                scope: this,
                load: this._onReleaseArtifactsLoaded
            }
        });
          
      },

    _renderChartBasedOnType: function () {
        if (this._getScopeType() === 'release') {
            this._fetchIterations();
        } else {
            this._addChart();
        }
    },

    _setScopeFromData: function (record) {
        this.scopeObject = record.data;
    },

    _getTimeboxesInScope: function (store, records) {
        var storeConfig = this.chartComponentConfig.storeConfig;
        var type = Ext.String.capitalize(this._getScopeType());
        var oids = [];
        var i;

        this.timeboxes = store.getItems();
        this._clearStoreConfig(storeConfig);

        for (i = 0; i < this.timeboxes.length; i++) {
            oids.push(this.timeboxes[i].ObjectID);
        }
        var useCurrentArtifacts = this.getSetting('useCurrentArtifacts')
        if (useCurrentArtifacts){
            console.log('useCurrentArtifacts',useCurrentArtifacts);
            this._fetchCurrentArtifactsForTimeboxes(type, this.timeboxes).then({
                scope: this,
                success: function(objectIds){
                    this.logger.log('_fetchCurrentArtifactsForTimeboxes success', objectIds);
                    storeConfig.find['ObjectID'] = { '$in' : objectIds };
                    this._renderChartBasedOnType();
                }, 
                failure: function(msg){
                    this.logger.log('_fetchCurrentArtifactsForTimeboxes failure: ' + msg);
                }
            });
        } else {
            storeConfig.find[type] = { '$in' : oids };
            this._renderChartBasedOnType();
        }
    },
    _fetchCurrentArtifactsForTimeboxes: function(timeboxType, timeboxOids){
        var deferred = Ext.create('Deft.Deferred');
       console.log(timeboxOids);
        var filters = Ext.create('Rally.data.wsapi.Filter',{
            property: timeboxType,
            value: timeboxOids[0]._ref
        });
        for (var i=1; i<timeboxOids.length; i++){
            filters = filters.or(Ext.create('Rally.data.wsapi.Filter',{
                property: timeboxType,
                value: timeboxOids[i]._ref
            }));
        }
       console.log('filters', filters.toString());
        Ext.create('Rally.data.wsapi.artifact.Store',{
            models: ['HierarchicalRequirement','Defect'],
            fetch: ["ObjectID"],
            filters: filters,
            autoLoad: true, 
            listeners: {
                scope: this,
                load: function(store, records, success){
                    console.log(store,records, success);
                    if (success){
                        var oids = _.map(records, function(r){return r.get('ObjectID')});
                        deferred.resolve(oids);
                    } else {
                        deferred.reject('_fetchTimeboxArtifactsFailed');
                    }
                }
            }
        });
        return deferred;
    },
    _onIterationsLoaded: function (store) {
        this.iterations = store.getItems();

        this._addChart();
        this.down('rallychart').on('snapshotsAggregated', this._addIterationLines, this);
    },

    _addDateBounds: function () {
        this._addDateBoundsToQuery();
        this._addDateBoundsToCalculator();
    },

    _addDateBoundsToQuery: function () {

    },

    _getNow: function() {
        return new Date();
    },

    _addDateBoundsToCalculator: function () {
        var calcConfig = this.chartComponentConfig.calculatorConfig;
        var endDate = this._getScopeObjectEndDate();
        var now = this._getNow();
        calcConfig.startDate = Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true);
        if(now > this._getScopeObjectStartDate() && now < this._getScopeObjectEndDate()) {
            endDate = now;
        }
        calcConfig.endDate = Rally.util.DateTime.toIsoString(endDate, true);
        // S53625: If the time-box has ended, disable the projection line
        if (now > this._getScopeObjectEndDate()) {
            calcConfig.enableProjections = false;
        } else {
            calcConfig.enableProjections = true;
        }
        // add scopeEndDate, which may or may not be the same as endDate
        calcConfig.scopeEndDate = this._getScopeObjectEndDate();
    },

    _addAggregationTypeToCalculator: function () {
        var calcConfig = this.chartComponentConfig.calculatorConfig;
        calcConfig.chartAggregationType = this.getSetting('chartAggregationType');
    },

    _updateCompletedScheduleStates: function () {
        var calcConfig = this.chartComponentConfig.calculatorConfig;
        calcConfig.completedScheduleStateNames = this.customScheduleStates;
    },

    _loadScopeObject: function (scopeRef) {
        Rally.data.ModelFactory.getModel({
            type: this._getScopeType(),

            context: {
                workspace: this.getContext().getWorkspaceRef(),
                project: null
            },
            success: function(model) {
                model.load(Rally.util.Ref.getOidFromRef(scopeRef), {
                    success: function(record) {
                        this._onScopeObjectLoaded(record);
                    },
                    scope: this
                });
            },
            scope: this
        });
    },

    _fetchIterations: function () {
        var store = Ext.create('Rally.data.wsapi.Store', {
            model: Ext.identityFn('Iteration'),
            filters: [
                {
                    property: 'StartDate',
                    operator: '>=',
                    value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                },
                {
                    property: 'EndDate',
                    operator: '<=',
                    value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                }
            ],
            context: {
                workspace: this.getContext().getWorkspaceRef(),
                project: this.getContext().getProjectRef()
            },
            fetch: ['Name','StartDate','EndDate'],
            limit: Infinity
        });

        store.on('load', this._onIterationsLoaded, this);
        store.load();
    },

    _areIterationsEqual: function (iteration1, iteration2) {
        return iteration1.Name === iteration2.Name &&
               iteration1.StartDate === iteration2.StartDate &&
               iteration1.EndDate === iteration2.EndDate;
    },

    _addIterationLines: function (chart) {
        var axis = chart.chartConfig.xAxis;
        var categories = chart.chartData.categories;
        var i, j;
        var uniqueIterations = [];
        var unique;

        axis.plotLines = [];
        axis.plotBands = [];

        for (i = 0; i < this.iterations.length; i++) {
            unique = true;
            for (j = 0; j < uniqueIterations.length; j++) {
                if(this._areIterationsEqual(uniqueIterations[j], this.iterations[i])) {
                    unique = false;
                    break;
                }
            }
            if(unique === true) {
                uniqueIterations.push(this.iterations[i]);
            }
        }

        for (i = 0; i < uniqueIterations.length; i++) {
            axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[i], false));
            axis.plotBands.push(this._getPlotBand(categories, uniqueIterations[i], i % 2 !== 0));
        }

        if (uniqueIterations.length > 0) {
            axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[uniqueIterations.length - 1], true));
        }
    },
    _buildLabelText: function(iteration) {
        var labelSetting = this.getSetting("showLabels");

        var text = '';
        if (labelSetting) {
            text = iteration.Name || '';
        }
        return text;
    },

    _getPlotBand: function (categories, iteration, shouldColorize) {
        var startDate = this.dateStringToObject(iteration.StartDate);
        var endDate = this.dateStringToObject(iteration.EndDate);

        var label =   {
                text: this._buildLabelText( iteration ),
                align: 'center',
                rotation: 0,
                y: -7
        };

        return {
            color: shouldColorize ? '#F2FAFF' : '#FFFFFF',
            from: this._getNearestWorkday(categories, startDate),
            to: this._getNearestWorkday(categories, endDate),

            label: label
        };
    },

    _getNearestWorkday: function(categories, date) {
        var dateStr = Ext.Date.format(date, 'Y-m-d');
        var index = categories.indexOf(dateStr);
        if(index === -1) {
            var workdays = this._getWorkspaceConfiguredWorkdays();
            if(workdays.length < 1) {
                return -1;
            }
            // date not in categories (probably) means it falls on a non-workday...back up to the next previous workday
            while (workdays.indexOf(Ext.Date.format(date, 'l')) === -1 && date > this._getScopeObjectStartDate()) {
                date = Ext.Date.add(date, Ext.Date.DAY, -1);
                dateStr = Ext.Date.format(date, 'Y-m-d');
                index = categories.indexOf(dateStr);
            }
        }
        return index;
    },

    _getPlotLine: function (categories, iteration, lastLine) {
        var dateObj;
        var dateIndex;

        if (lastLine) {
            dateObj = this.dateStringToObject(iteration.EndDate);
        } else {
            dateObj = this.dateStringToObject(iteration.StartDate);
        }

        dateIndex = this._getNearestWorkday(categories, dateObj);

        return {
            color: '#BBBBBB',
            dashStyle: 'ShortDash',
            width: 2,
            zIndex: 3,
            value: dateIndex
        };
    },

    _addChart: function () {
        this._updateChartConfigDateFormat();
        this._updateChartConfigWorkdays();
        var chartComponentConfig = Ext.Object.merge({}, this.chartComponentConfig);

        this.add(chartComponentConfig);
        this.down('rallychart').on('snapshotsAggregated', this._onSnapshotDataReady, this);
    },

    _onSnapshotDataReady: function (chart) {
        this._updateDisplayType(chart);
        this._updateXAxis(chart);
    },

    _updateDisplayType: function (chart) {
        var series = chart.chartData.series;
        var displayType = this.getSetting('chartDisplayType');
        var i;

        for (i = 0; i < series.length; i++) {
            if (this._seriesFollowsDisplayType(series[i])) {
                series[i].type = displayType;
            }
        }
    },

    _seriesFollowsDisplayType: function (series) {
        return series.name.indexOf('Ideal') === -1 && series.name.indexOf('Prediction') === -1;
    },

    _updateYAxis: function () {
        this._updateYAxisTitle();
        this._updateYAxisConfig();
    },

    _updateYAxisTitle: function () {
        var chartConfig = this.chartComponentConfig.chartConfig;
        chartConfig.yAxis = [
            {}
        ];
        chartConfig.yAxis[0].title = {
            text: this._getAxisTitleBasedOnAggregationType()
        };
    },

    _updateYAxisConfig: function () {
        var axis = this.chartComponentConfig.chartConfig.yAxis[0];
        axis.min = 0;
        axis.labels = {
            x: -5,
            y: 4
        };
    },

    _updateXAxis: function (chart) {
        if(this.container.dom.offsetWidth < 1000) {
            chart.chartConfig.xAxis.labels.staggerLines = 2;
        }
        chart.chartConfig.xAxis.labels.step = Math.round( chart.chartData.categories.length / 100 );
        chart.chartConfig.xAxis.tickInterval = this._configureChartTicks(chart.chartData.categories.length);
    },

    _configureChartTicks: function (days) {
        var pixelTickWidth = 125,
            appWidth = this.getWidth(),
            ticks = Math.floor(appWidth / pixelTickWidth);

        return Math.ceil(days / ticks);
    },

    _getAxisTitleBasedOnAggregationType: function () {
        var aggregationType = this.getSetting('chartAggregationType');
        if (aggregationType === 'storycount') {
            return 'Count';
        } else {
            return 'Points';
        }
    },

    _updateChartConfigDateFormat: function () {
        var self = this;

        this.chartComponentConfig.chartConfig.xAxis.labels.formatter = function () {
            return self._formatDate(self.dateStringToObject(this.value));
        };
    },

    _updateChartConfigWorkdays: function () {
        this.chartComponentConfig.calculatorConfig.workDays = this._getWorkspaceConfiguredWorkdays().split(',');
    },

    _parseRallyDateFormatToHighchartsDateFormat: function () {
        var dateFormat = this._getUserConfiguredDateFormat() || this._getWorkspaceConfiguredDateFormat();

        for (var i = 0; i < this.dateFormatters.length; i++) {
            dateFormat = dateFormat.replace(this.dateFormatters[i].key, this.dateFormatters[i].value);
        }

        return dateFormat;
    },

    _formatDate: function (date) {
        if (!this.dateFormat) {
            this.dateFormat = this._parseRallyDateFormatToHighchartsDateFormat();
        }

        return Highcharts.dateFormat(this.dateFormat, date.getTime());
    },

    _getUserConfiguredDateFormat: function () {
        return this.getContext().getUser().UserProfile.DateFormat;
    },

    _getWorkspaceConfiguredDateFormat: function () {
        return this.getContext().getWorkspace().WorkspaceConfiguration.DateFormat;
    },

    _getWorkspaceConfiguredWorkdays: function () {
        return this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays;
    },

    _updateChartTitle: function () {
        this.chartComponentConfig.chartConfig.title = this._buildChartTitle();
    },

    _buildChartTitle: function () {
        var widthPerCharacter = 10;
        var totalCharacters = Math.floor(this.getWidth() / widthPerCharacter);
        var title = this._getDefaultTitle();
        var align = 'center';

        if (this.scopeObject) {
            title = this.scopeObject.Name;
        }

        if (totalCharacters < title.length) {
            title = title.substring(0, totalCharacters) + '...';
            align = 'left';
        }

        return {
            text: title,
            align: align,
            margin: 30
        };
    },

    _getDefaultTitle: function () {
        return Ext.String.capitalize(this._getScopeType());
    },

    _settingsInvalid: function () {
        var chartAggregationType = this.getSetting('chartAggregationType'),
            chartDisplayType = this.getSetting('chartDisplayType'),
            chartTimebox = this.getSetting('chartTimebox');

        var invalid = function (value) {
            return !value || value === 'undefined';
        };

        return invalid(chartAggregationType) || invalid(chartDisplayType) ||
            this._chartTimeboxInvalid(chartTimebox);
    },

    _chartTimeboxInvalid: function (chartTimebox) {
        if (this.context.getTimeboxScope()) {
            return false;
        }

        return !chartTimebox || chartTimebox === 'undefined';
    },

    _saveScopeType: function () {
        this.scopeType = this._getScopeType();
    },

    _getScopeType: function () {
        if (this.isOnScopedDashboard()) {
            return this._getDashboardScopeType();
        } else {
            return this._getSavedScopeType();
        }
    },

    _getDashboardScopeType: function () {
        return this.getContext().getTimeboxScope().getType();
    },

    _getSavedScopeType: function () {
        return this.getSetting('chartTimebox');
    },

    _getScopePicker: function () {
        if (this.isOnScopedDashboard()) {
            return this.getContext().getTimeboxScope();
        } else {
            return this.down('rally' + this._getScopeType() + 'combobox');
        }
    },

    _getScopeObjectStartDateName: function () {
        if (!this.scopeObject) {
            return '';
        } else if (this.scopeObject._type === 'release') {
            return 'ReleaseStartDate';
        } else {
            return 'StartDate';
        }
    },

    _getScopeObjectEndDateName: function () {
        if (!this.scopeObject) {
            return '';
        } else if (this.scopeObject._type === 'release') {
            return 'ReleaseDate';
        } else {
            return 'EndDate';
        }
    },

    _getScopeObjectStartDate: function () {
        if (!this.scopeObject) {
            return this._getNow();
        } else if (this.scopeObject._type === 'release') {
            return this.scopeObject.ReleaseStartDate;
        } else {
            return this.scopeObject.StartDate;
        }
    },

    _getScopeObjectEndDate: function () {
        if (!this.scopeObject) {
            return this._getNow();
        } else if (this.scopeObject._type === 'release') {
            return this.scopeObject.ReleaseDate;
        } else {
            return this.scopeObject.EndDate;
        }
    },

    _clearStoreConfig: function (storeConfig) {
        if (storeConfig.find.hasOwnProperty('Release')) {
            delete storeConfig.find.Release;
        }

        if (storeConfig.find.hasOwnProperty('Iteration')) {
            delete storeConfig.find.Iteration;
        }
    },

    _loadUserStoryModel: function() {
        Rally.data.ModelFactory.getModel({
            type: "UserStory",
            context: this._getContext(),
            success: function(model) {
                this._getScheduleStateValues(model);
            },
            scope: this
        });
    },

    _getContext: function() {
        return {
            workspace: this.context.getWorkspaceRef(),
            project: null
        };
    },

    _getScheduleStateValues: function (model) {
        if(model) {
            model.getField("ScheduleState").getAllowedValueStore().load({
                callback: function(records, operation, success) {
                    var scheduleStates = _.collect(records, function(obj) {
                        return obj.raw;
                    });

                    var store = this._wrapRecords(scheduleStates);
                    var values = [];
                    var acceptedSeen = false;
                    for(var i = 0; i < store.data.items.length; i++) {
                        if(store.data.items[i].data.StringValue === 'Accepted') {
                            acceptedSeen = true;
                        }
                        if(acceptedSeen) {
                            values.push(store.data.items[i].data.StringValue);
                        }
                    }

                    if(values.length > 0) {
                        this.customScheduleStates = values;
                    }
                },
                scope: this
            });
        }
    },

    _wrapRecords: function(records) {
        return Ext.create("Ext.data.JsonStore", {
            fields: ["_ref", "StringValue"],
            data: records
        });
    },
    /********************************************
    /* Overrides for App class
    /*
    /********************************************/
    isExternal: function(){
      return typeof(this.getAppId()) == 'undefined';
    },
    //showSettings:  Override
    showSettings: function(options) {      
        this._appSettings = Ext.create('Rally.app.AppSettings', Ext.apply({
            fields: this.getSettingsFields(),
            settings: this.getSettings(),
            defaultSettings: this.getDefaultSettings(),
            context: this.getContext(),
            settingsScope: this.settingsScope,
            autoScroll: true
        }, options));
        
        this._appSettings.on('cancel', this._hideSettings, this);
        this._appSettings.on('save', this._onSettingsSaved, this);
        if (this.isExternal()){
            if (this.down('#settings_box').getComponent(this._appSettings.id)==undefined){
                this.down('#settings_box').add(this._appSettings);
            }
        } else {
            this.hide();
            this.up().add(this._appSettings);
        }
        return this._appSettings;
    },
    _onSettingsSaved: function(settings){
        Ext.apply(this.settings, settings);
        this._hideSettings();
        this.onSettingsUpdate(settings);
    },
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        //Build and save column settings...this means that we need to get the display names and multi-list
        var cycleStateFields_setting = this.getSetting('cycleStateFields');
        if (cycleStateFields_setting instanceof Array){
            cycleStateFields = cycleStateFields_setting;
        } else {
            cycleStateFields = cycleStateFields_setting.split(',');
        }
        this.logger.log('onSettingsUpdate',settings, cycleStateFields);
        this._fetchFields(cycleStateFields).then({
            scope: this,
            success: function(){
                this.logger.log('Valid fields for cycle and filter time', this.cycleFields, this.filterFields); 
                this._initializeApp(this.cycleFields);
            }
        });


    }


});
            
               Rally.launchApp('CustomApp', {
                   name: 'Current Data Release Burndown'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>